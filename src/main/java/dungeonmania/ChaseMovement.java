package dungeonmania;

import dungeonmania.util.Position;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.PriorityQueue;
import java.util.stream.Collectors;

public class ChaseMovement implements Movement {
    
    Entity target;

    public ChaseMovement() {

    }

    public boolean targetIsAdjacent(Position currentPos) {
        return Position.isAdjacent(currentPos, target.getPosition());
    }

    public void setTarget(Entity target) {
        this.target = target;
    }

    private String getPosString(PositionSimple pos){
        return ("(" + pos.getX() + ", " + pos.getY() + ")");
    }
    private void printSourceCol(Map<PositionSimple, Map<PositionSimple, Double>> grid, PositionSimple source){
        for(PositionSimple pos : grid.get(source).keySet()){
            System.out.println(getPosString(pos) + ":" + grid.get(source).get(pos));
        }
    }

    private List<PositionSimple> getAdjacentPositionsInGrid(PositionSimple pos, Map<PositionSimple, Map<PositionSimple, Double>> grid){
        return pos.getCardinallyAdjacentPositions().stream().filter(x -> grid.keySet().contains(x)).collect(Collectors.toList());
    }
    /**
     * Runs dijkstra's algorithm on a given adjacency matrix and source tile
     * @param grid
     * @param source
     * @return
     */
    private Map<PositionSimple, PositionSimple> dijkstras(Map<PositionSimple, Map<PositionSimple, Double>> grid, Position source){
        //printSourceCol(grid, source);
        PositionSimple sourceSimp = new PositionSimple(source);
        Map<PositionSimple, Double> dist = new HashMap<PositionSimple, Double>();
        Map<PositionSimple, PositionSimple> prev = new HashMap<PositionSimple, PositionSimple>();

        for(PositionSimple p : grid.keySet()){
            dist.put(p, Double.POSITIVE_INFINITY);
            prev.put(p, null);
        }
        dist.put(sourceSimp, 0.0);
        PriorityQueue<PositionSimple> queue = new PriorityQueue<PositionSimple>(grid.keySet().size(), (a, b) -> Double.compare(dist.get(a), dist.get(b)));
        queue.add(sourceSimp);
        while(!queue.isEmpty()){
            PositionSimple u = queue.remove();
            for(PositionSimple v : getAdjacentPositionsInGrid(u, grid)){
                /*printSourceCol(grid, u);
                System.out.println("v now");
                printSourceCol(grid, v);*/
                if(grid.get(u).get(v) != Double.POSITIVE_INFINITY){
                    if(dist.get(u) + grid.get(u).get(v) < dist.get(v)){
                        dist.put(v, dist.get(u) + grid.get(u).get(v));
                        prev.put(v, u);
                        queue.add(v);
                    }
                }
            }
        }
        return prev;
    }
    /**
     * Walks back through map generated by dijkstra
     * @param placeInPath
     * @param pre
     * @param source
     * @param init
     * @return
     */
    private Position walkBackThroughPath(PositionSimple placeInPath, Map<PositionSimple, PositionSimple> pre, Position source, Position init){
        PositionSimple last = pre.get(placeInPath);
        PositionSimple sourceSimp = new PositionSimple(source);
        if(last == null){
            System.out.println("Nowhere to move");
            return init;
        }
        if(Objects.equals(last, sourceSimp)){
            System.out.println(placeInPath);
            return new Position(placeInPath.getX(), placeInPath.getY());
        }
        return walkBackThroughPath(last, pre, source, init);
    }
    
    /**
     * Move object by 1 in the direction that would minimise
     * distance to target
     */
    @Override
    public Position move(Position currentPos, Map<PositionSimple, Map<PositionSimple, Double>> grid) {
        Map<PositionSimple, PositionSimple> ret = dijkstras(grid, currentPos);
        //printMap(ret);
        return walkBackThroughPath(new PositionSimple(target.getPosition()), ret, currentPos, currentPos);
    }

}
