package dungeonmania;

import dungeonmania.util.Position;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.PriorityQueue;
import java.util.stream.Collectors;

public class ChaseMovement implements Movement {
    
    Entity target;

    public ChaseMovement() {

    }

    /**
     * Move object by 1 in the direction that would minimise
     * distance to target
     */
    /*public Position move(Position currentPos, Map<PositionSimple, Map<PositionSimple, Double>> grid) {

        if (target == null) {
            return currentPos;
        }

        // Get position vector from this object to the target
        Position dir = Position.calculatePositionBetween(currentPos, target.getPosition());
        Position offset;

        // This object is on the same tile as target, dont move
        if (dir.equals(new Position(0,0))) {
            return currentPos;
        }

        // Get component of vector with greatest magnitude and move 1 tile in that direction
        if (Math.abs(dir.getX()) >= Math.abs(dir.getY())) {
            int normalisedX = dir.getX()/Math.abs(dir.getX());
            offset = new Position(normalisedX, 0);
        } else {
            int normalisedY = dir.getY()/Math.abs(dir.getY());
            offset = new Position(0, normalisedY);   
        }
        return currentPos.translateBy(offset);
    }
*/
    public boolean targetIsAdjacent(Position currentPos) {
        return Position.isAdjacent(currentPos, target.getPosition());
    }

    public void setTarget(Entity target) {
        this.target = target;
    }

    private String getPosString(PositionSimple pos){
        return ("(" + pos.getX() + ", " + pos.getY() + ")");
    }
    private void printSourceCol(Map<PositionSimple, Map<PositionSimple, Double>> grid, PositionSimple source){
        for(PositionSimple pos : grid.get(source).keySet()){
            System.out.println(getPosString(pos) + ":" + grid.get(source).get(pos));
        }
    }

    private List<PositionSimple> getAdjacentPositionsInGrid(PositionSimple pos, Map<PositionSimple, Map<PositionSimple, Double>> grid){
        return pos.getCardinallyAdjacentPositions().stream().filter(x -> grid.keySet().contains(x)).collect(Collectors.toList());
    }
    private Map<PositionSimple, PositionSimple> dijkstras(Map<PositionSimple, Map<PositionSimple, Double>> grid, Position source){
        //printSourceCol(grid, source);
        PositionSimple sourceSimp = new PositionSimple(source);
        Map<PositionSimple, Double> dist = new HashMap<PositionSimple, Double>();
        Map<PositionSimple, PositionSimple> prev = new HashMap<PositionSimple, PositionSimple>();

        for(PositionSimple p : grid.keySet()){
            dist.put(p, Double.POSITIVE_INFINITY);
            prev.put(p, null);
        }
        dist.put(sourceSimp, 0.0);
        PriorityQueue<PositionSimple> queue = new PriorityQueue<PositionSimple>(grid.keySet().size(), (a, b) -> Double.compare(dist.get(a), dist.get(b)));
        queue.add(sourceSimp);
        while(!queue.isEmpty()){
            PositionSimple u = queue.remove();
            for(PositionSimple v : getAdjacentPositionsInGrid(u, grid)){
                /*printSourceCol(grid, u);
                System.out.println("v now");
                printSourceCol(grid, v);*/
                if(grid.get(u).get(v) != Double.POSITIVE_INFINITY){
                    if(dist.get(u) + grid.get(u).get(v) < dist.get(v)){
                        dist.put(v, dist.get(u) + grid.get(u).get(v));
                        prev.put(v, u);
                        queue.add(v);
                    }
                }
            }
        }
        return prev;
    }
    /*
    Getting stack overflow
        - Print out map generated by dijkstras - could be problem
        - The recursion below looks fine, but it could be what's causing issues, take another look
    */

    private Position walkBackThroughPath(PositionSimple placeInPath, Map<PositionSimple, PositionSimple> pre, Position source, Position init){
        PositionSimple last = pre.get(placeInPath);
        PositionSimple sourceSimp = new PositionSimple(source);
        if(last == null){
            System.out.println("Nowhere to move");
            return init;
        }
        if(Objects.equals(last, sourceSimp)){
            System.out.println(placeInPath);
            return new Position(placeInPath.getX(), placeInPath.getY());
        }
        return walkBackThroughPath(last, pre, source, init);
    }
    /*private void printMap(Map<Position, Position> pre){
        if(pre == null){
            return;
        }
        for(Position pos : pre.keySet()){
            System.out.println("(" + pos.getX() + ", " + pos.getY() + ") from (" + pre.get(pos).getX() + ", " + pre.get(pos).getY()); 
        }
    }*/
    
    @Override
    public Position move(Position currentPos, Map<PositionSimple, Map<PositionSimple, Double>> grid) {
        Map<PositionSimple, PositionSimple> ret = dijkstras(grid, currentPos);
        //printMap(ret);
        return walkBackThroughPath(new PositionSimple(target.getPosition()), ret, currentPos, currentPos);
    }

}
